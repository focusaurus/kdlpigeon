{
// Package kdl parses [kdl][https://github.com/kdl-org/kdl/blob/main/SPEC.md]. [kdl.dev]().
//
package kdl

type ValueType int

const (
	NullValue ValueType = iota
	BoolValue
	Float64Value
	StringValue
)

type Value struct {
  Type ValueType
  String string
  Float64 float64
  Bool bool
}

type Node struct {
  Identifier string
  Values []Value
}

func String(n *Node) string {
  rep := n.Identifier
  for _, val := range n.Values {
    rep += " "
    switch val.Type {
    case NullValue:
    rep += "nil"
    case BoolValue:
    if val.Bool {
    rep += "true"
    } else {
    rep += "false"
    }
    case Float64Value:
    rep += fmt.Sprintf("%d", val.Float64)
    case StringValue:
    rep += val.String
  }
  }
  return rep
}

func toAnySlice(v any) []any {
    if v == nil {
        return nil
    }
    return v.([]any)
}
}

nodes = linespace* nodes:(node nodes?)? linespace*
node = id:identifier valuesRaw:(node_space+ value)* node_space* node_terminator {
  values := make([]Value, 0)
  spaceThenValues := toAnySlice(valuesRaw)
  // fmt.Printf("values: %+v", spaceThenValues)
  for _, spaceThenValue := range spaceThenValues {
    afterSpace := toAnySlice(spaceThenValue)[1]
    if afterSpace == nil {
      values = append(values, Value{Type: NullValue})
      continue
    }
    valBool, ok := afterSpace.(bool)
    if ok {
      values = append(values, Value{Type: BoolValue, Bool: valBool})
      continue
    }
    valFloat64, ok := afterSpace.(float64)
    if ok {
      values = append(values, Value{Type: Float64Value, Float64: valFloat64})
    }
    valString, ok := afterSpace.(string)
    if ok {
      values = append(values, Value{Type: StringValue, String: valString})
    }
  }
  return Node{
    Identifier: string(id.([]byte)),
    Values: values,
  }, nil
}
node_terminator = single_line_comment / newline / ';' / eof
node_space = ws* escline ws* / ws+
escline = '\\' ws* (single_line_comment / newline)
bom = '\uFEFF'
// TODO add rest from table in spec
unicode_space = [ ]
ws = bom / unicode_space
// TODO add rest from table in spec
newline = [\n]
linespace = newline / ws / single_line_comment
single_line_comment = "//" newline+ (newline / eof)
identifier = [a-zA-Z]+ { return c.text, nil }
node_space = ws+
eof = !.
boolean = "true" { return true, nil } / "false" { return false, nil }
null = "null" { return nil, nil }
keyword = boolean / null
value = number / keyword / String
number = '-'? Integer ( '.' DecimalDigit+ )? Exponent? {
    // JSON numbers have the same syntax as Go's, and are parseable using
    // strconv.
    return strconv.ParseFloat(string(c.text), 64)
}

Integer = '0' / NonZeroDecimalDigit DecimalDigit*

Exponent = 'e'i [+-]? DecimalDigit+

DecimalDigit = [0-9]

NonZeroDecimalDigit = [1-9]
EscapedChar = [\x00-\x1f"\\]

SingleCharEscape = ["\\/bfnrt]

UnicodeEscape = 'u' HexDigit HexDigit HexDigit HexDigit

EscapeSequence = SingleCharEscape / UnicodeEscape

String = '"' ( !EscapedChar . / '\\' EscapeSequence )* '"' {
    c.text = bytes.Replace(c.text, []byte(`\/`), []byte(`/`), -1)
    return strconv.Unquote(string(c.text))
}

/*
nodes = linespace* (node nodes?)? linespace*
node = identifier (node_space+ value)*

identifier = bare_identifier

node = identifier (node_space+ value)* node_space* node_terminator
node_terminator = single_line_comment / newline / ';' / eof

Document = _ node:Node+ eof {
    return node, nil
}

Node = node:(Identifier) _ {
    return node, nil
}


BareIdentifier = id:()

Identifier = String / BareIdentifier


HexDigit = [0-9a-f]i


Null = "null" { return nil, nil }

_ "whitespace" = [ \t\r\n]*

*/
